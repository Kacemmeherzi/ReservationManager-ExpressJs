{"version":3,"file":"polling-observer.js","sourceRoot":"","sources":["../../src/polling-observer/polling-observer.ts"],"names":[],"mappings":"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","sourcesContent":["import { delayUntil } from '../delay-until/index';\nimport { PollingMeasure } from './polling-measure';\n\nexport interface PollingObserverOptions {\n  timeout?: number;\n  interval?: number;\n}\ntype PollingCallback<T> = () => T | Promise<T>;\ntype ConditionCallback<T> = (\n  data: T | null | undefined,\n  records: PollingObserver<T>['_records'],\n  object: PollingObserver<T>\n) => boolean | Promise<boolean>;\n\nexport interface OnfinishFulfilled<T> {\n  status: 'finish' | 'timeout';\n  value: T | null | undefined;\n}\nexport interface OnfinishRejected {\n  readonly status: 'error';\n  reason: Error;\n}\nexport type OnfinishValue<T> = OnfinishFulfilled<T> | OnfinishRejected;\ntype OnfinishCallback<T> = (\n  value: OnfinishValue<T>,\n  records: PollingObserver<T>['_records'],\n  object: PollingObserver<T>\n) => unknown;\n\nfunction isPromise<T>(r: T | Promise<T>): r is Promise<T> {\n  return 'function' === typeof((r as Promise<T>).then);\n}\n\nconst perf = globalThis.performance;\n\nexport class PollingObserver<T> {\n  public onfinish?: OnfinishCallback<T>;\n\n  private _forceStop = false;\n  private _records: PollingMeasure[] = [];\n  private _isPolling = false;\n\n  constructor(public conditionCallback: ConditionCallback<T>) {\n    if ('function' !== typeof(conditionCallback)) {\n      throw new TypeError(`'conditionCallback' is not defined`);\n    }\n  }\n\n  public disconnect(): void {\n    this._forceStop = true;\n\n    if (!this._isPolling) this._records = [];\n  }\n\n  public async observe(\n    callback: PollingCallback<T>,\n    options?: PollingObserverOptions\n  ): Promise<void> {\n    /**\n     * NOTE(motss): To ensure `this._forceStop` is always reset before start observing.\n     */\n    this._forceStop = false;\n\n    const { interval, timeout }: PollingObserverOptions = options || {};\n    const isValidInterval = 'number' === typeof(interval) && interval > 0;\n    const obsTimeout = 'number' === typeof(timeout) ? +timeout : -1;\n    const obsInterval = isValidInterval ? +(interval as number) : 100;\n\n    const isInfinitePolling = obsTimeout < 1;\n    const records = this._records;\n    const onfinishCallback = this.onfinish;\n    const conditionCallback = this.conditionCallback;\n    const loop = true;\n\n    let totalTime = 0;\n    let value: T | null | undefined = void 0;\n    let i = 0;\n    let status: OnfinishFulfilled<T>['status'] = 'finish';\n    let result: OnfinishValue<T> = {} as OnfinishValue<T>;\n\n    try {\n      polling: while (loop) {\n        if (this._forceStop) break polling;\n\n        /** NOTE(motss): Set to indicate polling initiates */\n        this._isPolling = true;\n\n        const conditionResult = conditionCallback(value, records, this);\n        const didConditionMeet = isPromise(conditionResult) ?\n          await conditionResult : conditionResult;\n        const didTimeout = isInfinitePolling ? false : totalTime >= obsTimeout;\n\n        if (didTimeout || didConditionMeet) {\n          status = didTimeout ? 'timeout' : status;\n          break polling;\n        }\n\n        const startAt = perf.now();\n        const r = callback();\n        value = isPromise(r) ? await r : r;\n        const endAt = perf.now();\n        const duration = endAt - startAt;\n        const timeLeft = isValidInterval ? obsInterval - duration : 0;\n\n        records.push(new PollingMeasure(`polling:${i}`, duration, startAt));\n\n        totalTime += (duration > obsInterval ? duration : obsInterval);\n        i += 1;\n\n        if (timeLeft > 0) await delayUntil(timeLeft);\n      }\n\n      result = { status, value };\n    } catch (e) {\n      result = { status: 'error', reason: e as Error };\n    } finally {\n      const recordsSlice = records.slice();\n\n      if (this._forceStop) this._records = [];\n\n      /** NOTE(motss): Reset flags */\n      this._isPolling = this._forceStop = false;\n\n      if ('function' === typeof(onfinishCallback)) {\n        onfinishCallback(result, recordsSlice, this);\n      }\n    }\n  }\n\n  public takeRecords(): PollingMeasure[] {\n    return this._records;\n  }\n}\n"]}